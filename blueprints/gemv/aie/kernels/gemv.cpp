// This file was auto-generated by aieblas on 2024-7-19 at 13:38

#include "gemv.hpp"

#define NUM_SAMPLES 64

uint64 chess_storage(%chess_alignof(v4int64)) counter[4] = {0, 0, 0, 0};
int32 chess_storage(%chess_alignof(v8int32)) scalar[8] = {0, 0, 0, 0, 0, 0, 0, 0};

void gemv(input_stream<int32> *__restrict alpha, input_window<int32> *__restrict A, input_window<int32> *__restrict x, input_stream<int32> *__restrict beta, input_window<int32> *__restrict y, output_window<int32> *__restrict out) {
    uint64 *cycle = &counter[1];
    int32 *alpha_store = &scalar[0];
    int32 *beta_store = &scalar[1];
    int32 *scalar_set = &scalar[2];

    if (*scalar_set == 0) {
        *scalar_set = 1;
        *alpha_store = readincr(alpha);
        *beta_store = readincr(beta);
    }

    if (*cycle == 0) {
        window_acquire(x);
    }

    if (*cycle % NUM_SAMPLES == 0) {
        window_acquire(y);
        window_acquire(out);
    }
    constexpr unsigned NUM_LOOPS = NUM_SAMPLES / 4;

    aie::vector<int32, 4> vx, vA;
    aie::vector<int32, 4> vout = aie::zeros<int32, 4>();
    for (unsigned i = 0; i < NUM_LOOPS; i++) {
        vA = window_readincr_v<4>(A);
        vx = window_readincr_v<4>(x);
        vout = aie::add(vout, aie::mul(vA, vx).to_vector<int32>());
    }
    window_decr_v4(x, NUM_LOOPS);

    int32 vy = window_readincr(y);
    window_writeincr(out, *alpha_store * aie::reduce_add(vout) + *beta_store * vy);

    *cycle += 1;

    if (*cycle % NUM_SAMPLES == 0) {
        window_release(y);
        window_release(out);
    }
}
